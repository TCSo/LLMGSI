{
    "subject": "[Scheme] Problem 15",
    "content": "<a href=\"https://cs61a.org/proj/scheme//#problem-15-1-pt\">Problem 15</a>\n\n<p> Please post all questions you have below concerning Problem 15 in the follow-ups.\n\n</p><p> If you are stuck on this question, feel free to read through the follow-up responses to see if you can draw any ideas from them.\n</p>",
    "threads": [
        {
            "question": "Can anyone give me a hint on this: \"As a result, a `MuProcedure` does not need to store an environment as an instance attribute. It can refer to names in the environment from which it was called.\"  How to refer to names in the environment from which it was called??",
            "follow-ups": [
                {
                    "feedback": "New frames are generated by scheme_apply, since it calls make_call_frame.  In Problem 11, when we wrote make_call_frame for LambdaProcedure, we didn't actually use the value for env that was passed in — we instead used self.env.  From the instructions for Problem 11:  Since lambdas are lexically scoped, your new frame should be a child of the frame in which the lambda is defined. **The** **`env` provided as an argument to `make_call_frame`** **is instead the frame in which the procedure is called, which will be useful when you implement dynamically scoped procedures in problem 15**."
                },
                {
                    "feedback": "Ahh got it! It's actually much easier than I expected!!"
                },
                {
                    "feedback": "I am creating a child frame for env (not self.env) for the make_call_frame method of MuProcedure and it is failing on the first test. It seems an environment is being created that doesn't refer to the environment in which the muprocedure is being called, but isn't that what creating a child frame for env should do? help is very much appreciated:)"
                },
                {
                    "feedback": "Your reasoning sounds correct. What specific error are you getting?"
                },
                {
                    "feedback": "scm> (define y 1)  y  scm> (define f (mu (x) (+ x y)))  f  scm> (define g (lambda (x y) (f (+ x x))))  g  scm> (g 3 7)  7  # Error: expected  # 13  # but got  # 7"
                },
                {
                    "feedback": "I think your `MuProcedure` isn’t correctly utilizing the `env` it’s called in, since it’s getting `y = 1` from the global frame. Make sure `make_call_frame` is correctly constructing a child frame **from the frame that is is called in**, or the `env` that is passed in to `make_call_frame`."
                },
                {
                    "feedback": "I got it- turns out the problem wasn't in the MuProcedure at all - it was in the do_mu_form. I was inputting one element as the second argument to MuProcedure, rather than giving it a list of args as its body."
                },
                {
                    "feedback": "scm> (define y 1)  y  scm> (define f (mu (x) (+ x y)))  f  scm> (define g (lambda (x y) (f (+ x x))))  g  scm> (g 3 7)  Can someone please walk me through the thought process behind this and explain why the answer for this is 13?"
                },
                {
                    "feedback": "When a `MuProcedure` is called, its body is evaluated in the environment that the call is made in rather than the environment in which the `MuProcedure` is defined. `(g 3 7)` will call g with x bound to 3 and y bound to 7. This returns the result of calling f with x bound to x + x (which becomes 3 + 3, or 6). When `(+ x y)` gets evaluated, x is bound to 6, but what is y? y becomes the value of y in the environment in which f is called, and that value is 7. So the final output is 6 + 7 = 13. The reason x is bound to 6 when f is executed and not 3 is because the binding of x that exists in g's environment gets overridden by the parameter x that f takes in."
                },
                {
                    "feedback": "This is all because the parent frame of the call frame made by calling a `MuProcedure` becomes the environment in which the `MuProcedure` was called."
                }
            ]
        },
        {
            "question": "I don't understand this part (the end of problem 15):  \"Make sure to remove all of the (exit) commands, so that all the tests are run! We've provided 115 tests (not counting the extra credit tests), so if you don't see at least that many tests passed, you haven't removed all the (exit) commands. (Of course, you should have many more than that, since you've been writing your own as well.)\"  When I run \"python3 ok -q tests.scm\", I only passed 11 test cases (but failed 0)..  Where do the 115 tests come from? How to remove all (exit) commands? Thank you guys.",
            "follow-ups": [
                {
                    "feedback": "Open `tests.scm` and remove the line that has the `(exit)` call on it."
                }
            ]
        },
        {
            "question": "I've removed all the (exit) commands in tests.scm but when I submit by running \"python3 ok --submit\" it's running test cases for question 16. When I run \"python3 ok -q tests.scm\" I pass 116 test cases. Any idea on what may be going on and how I may fix this?  ![](/redirect/s3?bucket=uploads&prefix=attach%2Fjziyku5gomy7aq%2Fjzdh1m6bebw351%2Fk2r9k3a6t9ep%2Fscheme_piazza_post1.PNG)  ![](/redirect/s3?bucket=uploads&prefix=attach%2Fjziyku5gomy7aq%2Fjzdh1m6bebw351%2Fk2r9kq9fyi31%2Fscheme_piazza_post2.PNG)",
            "follow-ups": [
                {
                    "feedback": "Since you're asking this on the Piazza post for question 15, I'm assuming you haven't done problems 16 and beyond. All of the fails you are getting are because you simply haven't finished the project. When you run `python3 ok` it's gonna try to run the test cases for all problems. Also for tests.scm, there were some optional tests (for the extra credit) that you may want to add the `(exit)` command back in for to prevent from running."
                },
                {
                    "feedback": "I have the same problem when I try to submit the first phase of the project to get the checkpoint credit. Does this mean that my project is already submitted up to the checkpoint?"
                },
                {
                    "feedback": "As long as you are passing the Ok test cases up to Problem 15 and at least 115 test cases in `tests.scm`, you should be set. If you have already submitted, then you will get your checkpoint point."
                }
            ]
        },
        {
            "question": "Sorry, this might sound like a stupid question, but how do you open the tests.scm file to remove the exits?",
            "follow-ups": [
                {
                    "feedback": "nvm figured it out"
                }
            ]
        },
        {
            "question": "Why am I only passing 110 test cases instead of 115? I removed all the (exit) commands from the tests.scm... I also passed the 91 test cases (via python3 ok --submit) and passed all the individual question test cases. Is there still something wrong with my code that the 91 test cases did not catch, that somehow the 115 extra test cases did?  sad reacts if there are more errors :(((  ![](/redirect/s3?bucket=uploads&prefix=attach%2Fjziyku5gomy7aq%2Fjzdf6t609dm4sp%2Fk2u9w675su4d%2FScreenshot_20191111_at_2.17.12_AM.png)",
            "follow-ups": [
                {
                    "feedback": "All the tests after the first five are meant to be passed after you have solved problems after problem 15. The first five, however, are supposed to pass, so it’s likely you’ve made a subtle mistake in your code somewhere. Check out what tests you’re failing in `tests.scm` by opening the file and going to those line numbers. It looks like you might have a subtle issue with your `eval_all` implementation, since only the last `print` statement is being executed, or it could also be a problem with `BuiltinProcedure`. Either way, good luck, and happy debugging!"
                }
            ]
        },
        {
            "question": "Ignore this comment. I meant to reply to someone else."
        },
        {
            "question": "I have only done 1 - 15, yet when I checked all 115 test cases, I passed 116. This is not something to worried about right? I have not added any cases either.",
            "follow-ups": [
                {
                    "feedback": "^OP. When I submitted though, I passed only 91. Is there anything I am missing?"
                },
                {
                    "feedback": "Hmmm, I don’t think it’s anything to worry about about, although it is a little odd that you have an extra test case. But as long as you’re passing the Ok cases and the extra cases for `tests.scm`, I think you should be fine."
                },
                {
                    "feedback": "Keep in mind there are two sets of cases: the 91 Ok cases and the 115 (or seemingly 116 in your case) `tests.scm` cases. The former are run just with `python3 ok`, and the latter are run with `python3 ok -q tests.scm`. If you you’re passing 91 cases and 115 cases, respectively, then you have completed the normal part of the project!"
                },
                {
                    "feedback": "same here, passed 116 cases instead of 115"
                },
                {
                    "feedback": "Oh, I just realized that I also passed 116 instead of 115 without the extra credit cases. Maybe it’s a typo on the website."
                }
            ]
        },
        {
            "question": "I removed the (exit) in tests.scm, but I got a weird error  ![](/redirect/s3?bucket=uploads&prefix=attach%2Fjziyku5gomy7aq%2Fjzw8xfv1bya23u%2Fk2wvceoao5hf%2FEKO9BJ9VHU1MF4NJH06.png)",
            "follow-ups": [
                {
                    "feedback": "if you only removed the first (exit), and this error is caused, I would try redownloading and replacing the tests.scm file."
                }
            ]
        },
        {
            "question": "We haven't removed any of the (exit) commands, yet we pass all the 116 tests provided. When we remove them, we fail some tests but still pass 116 tests. Should we still remove the (exit) commands?",
            "follow-ups": [
                {
                    "feedback": "No, don't remove them, since you're already at 116 tests passed. The remaining `(exit)` commands are for the extra credit problems."
                }
            ]
        },
        {
            "question": "Hi, I pass 116 tests when I do python ok -q tests.scm but only 91 when I use python ok --submit. Is this okay for getting the point for passing the tests?",
            "follow-ups": [
                {
                    "feedback": "Yes, this is normal behavior."
                },
                {
                    "feedback": "Okay, thanks a ton!"
                }
            ]
        },
        {
            "question": "So just for clarification I know this was mentioned earlier, but even if it shows when I submit that 91 were passed before failing but in tests.scm I pass all 116, then I'm good for the checkpoint?  ![](/redirect/s3?bucket=uploads&prefix=attach%2Fjziyku5gomy7aq%2Fjzkv017wndk6xr%2Fk2z7re23xjki%2FScreen_Shot_20191114_at_1.13.41_PM.png)",
            "follow-ups": [
                {
                    "feedback": "Yes."
                }
            ]
        },
        {
            "question": "I pass only 104 tests. However, when I try failed cases in (in my interpreter python3 scheme.py), everything works. What could be the problem?",
            "follow-ups": [
                {
                    "feedback": "What case are you failing?"
                }
            ]
        },
        {
            "question": "When I submit, the terminal outputs failed test cases for problem 16, although that's not part of the checkpoint. All my code for phases 1 and 2 pass all the tests in tests.scm, so I should be okay, right?",
            "follow-ups": [
                {
                    "feedback": "Nevermind - I saw a similar resolved question :)"
                }
            ]
        },
        {
            "question": "Does anyone know what # questions these tests correspond to?  ![](/redirect/s3?bucket=uploads&prefix=attach%2Fjziyku5gomy7aq%2Fjjzd058lyeugr%2Fk2zoemsz70o6%2FScreen_Shot_20191114_at_9.00.52_PM.png)",
            "follow-ups": [
                {
                    "feedback": "You can actually open the questions.scm file and see what the individual tests are, since the line numbers are given to you."
                }
            ]
        },
        {
            "question": "Problem 15 > Suite 1 > Case 1  scm> (define y 1)  y  scm> (define f (mu (x) (+ x y)))  f  scm> (define g (lambda (x y) (f (+ x x))))  g  scm> (g 3 7)  # Error: int is not callable: 1  # Error: expected  # 13  # but got  # Traceback (most recent call last):  # ...  # SchemeError: int is not callable: 1  Run only this test case with \"python3 ok -q 15 --suite 1 --case 1\"  \\---------------------------------------------------------------------  This is the error I'm getting. In the do_mu_form function, I defined a MuProcedure instance, and then I defined a Lambda that just executes the Mu Prodecure's body called on its arguments. Lastly, I return scheme_apply called on the lambda, the MuProcedure instance, and the current environment.  In the MuProcedure class, I defined a function make_call_frame which takes in args and env. It returns a child frame made from env, with self.formals and the args passed in to create the child frame.",
            "follow-ups": [
                {
                    "feedback": "Your `do_mu_form` implementation seems convoluted - use `do_lambda_form` as a reference for what your `do_mu_form` implementation should look like (you implemented this in Q8). Your `make_call_frame` implementation sounds correct."
                },
                {
                    "feedback": "Remember that `MuProcedure`s can be applied just like `LambdaProcedure`s, so you don’t need to wrap one in another. Thus is the power of abstraction—`Procedure`s are just things that can be applied to operands."
                },
                {
                    "feedback": "Ok, I've removed the references to lambdas, so now do_mu_form just makes a MuProcedure object and passes it in as an argument to scheme_apply, along with formals and env. But now the error says:  Problem 15 > Suite 1 > Case 1  scm> (define y 1)  y  scm> (define f (mu (x) (+ x y)))  # Error: unknown identifier: x  # Error: expected  # f  # but got  # Traceback (most recent call last):  # ...  # SchemeError: unknown identifier: x  Run only this test case with \"python3 ok -q 15 --suite 1 --case 1\"  \\---------------------------------------------------------------------  I think it is being raised in the MuProcedure's make_call_frame method, probably around the point when I call eval_all on the args. If I don't call eval_all (just say 'args'), and keep everything else the same, then the error changes to:  Problem 15 > Suite 1 > Case 1  scm> (define y 1)  y  scm> (define f (mu (x) (+ x y)))  FORMALS (x)  # Error: operand 0 (x) is not a number  # Error: expected  # f  # but got  # Traceback (most recent call last):  # ...  # SchemeError: operand 0 (x) is not a number  Run only this test case with \"python3 ok -q 15 --suite 1 --case 1\"  \\---------------------------------------------------------------------"
                },
                {
                    "feedback": "`do_mu_form` is supposed to *construct* a `MuProcedure`, not take one in. You should really implement `MuProcedure` the same way you implemented `LambdaProcedure`, but when you implement `make_call_frame`, the `Frame` child be a child of the **frame the mu procedure was called in**, not the frame in which it was defined. This also means that `MuProcedure`s don’t have to store what frame they were defined in in the first place, but otherwise, your `do_mu_form` should be homologous to `do_lambda_form`, and your `MuProcedure` should be homologous to your `LambdaProcedure`."
                },
                {
                    "feedback": "This worked, thank you! It turned out that I also shouldn't be calling eval_all on the args."
                }
            ]
        },
        {
            "question": "If I pass 91 cases while submitting, will I still get a check point for Part I and II, even if I pass only 115 tests in test.scm?",
            "follow-ups": [
                {
                    "feedback": "Those numbers sound correct; you're good."
                }
            ]
        },
        {
            "question": "Does anybody know why these test cases are not passing?  ![](/redirect/s3?bucket=uploads&prefix=attach%2Fjziyku5gomy7aq%2Fjzqdhpzk92h43c%2Fk328sa2y680m%2FScreen_Shot_20191116_at_4.06.19_PM.png)",
            "follow-ups": [
                {
                    "feedback": "It looks like you’re failing to evaluate some symbols at some point, since all the errors involve the symbol `x` where its value should be. I would start by checking your `eval_all` implementation, but the problem could ultimately be in a number of places."
                },
                {
                    "feedback": "I found the problem, however, I am not sure how to fix the issue. On problem 18, I had to do (car `(, expr)) to get expr. When I just put expr it returned expr and not what expr was bound to. I checked through scheme_eval, eval_all, scheme_read, and read_tail and I can't find any issues."
                },
                {
                    "feedback": "I'm not using a macro. For some reason, when I use expr, it will just return expr. This is just like how abs(x) was implemented (one of the cases I am having issues with).                (define (abs x)          (cond ((> x 0) x)          \t ((= x 0) 0)       \t ((< x 0) (-x))))  It passes the x = 0 and x < 0 case. However, when it has to return just x, that is where the problem lies. I'm not too sure where in my code is causing this problem."
                },
                {
                    "feedback": "To the question two posts above, you probably want to get the first element of the expression **before** it is returned from the macro, so it would probably be something more like `,(car expr)`."
                },
                {
                    "feedback": "To the question which is… also two posts above from this one, what is being returned? Just the symbol `x`?"
                },
                {
                    "feedback": "I believe so. Not sure what is causing that problem though."
                },
                {
                    "feedback": "Is your `cond` calling `eval_all` on the rest of the clause? I can’t really think of why it wouldn’t be working, I’m afraid."
                },
                {
                    "feedback": "Thank you so much. That was the issue."
                }
            ]
        },
        {
            "question": "I ran ok -q tests.scm and I pass 116 test cases, but since I ran the command after the first checkpoint deadline, will I still receive the extra credit point?",
            "follow-ups": [
                {
                    "feedback": "The submission only contains your code, not whether you actually ran the tests or not, so as long as the code that passes the tests is the same as the code in the submission, you should be fine."
                },
                {
                    "feedback": "You probably want to get the first element of `expr` *before* you return from the macro to get the first value of the expression, so it would be more like `,(car expr)` to evaluate the entire `car` procedure in the macro."
                },
                {
                    "feedback": "Cant pass this test for the life of me help pls."
                },
                {
                    "feedback": "Which test? You may want to start your own thread if you have a new issue. We’d love to help—we’re going to need more info in order to do so."
                }
            ]
        },
        {
            "question": "Help passing this test????  ![](/redirect/s3?bucket=uploads&prefix=attach%2Fjziyku5gomy7aq%2Fjzqdjbhgcj5er%2Fk389b14yk7vi%2Flife_of_me.PNG)",
            "follow-ups": [
                {
                    "feedback": "Could you show what output you’re getting?"
                },
                {
                    "feedback": "In general, you should essentially be mirroring what you do in your `do_lambda_form` in the `do_mu_form`. The only difference is the parent of the child frame that gets created: a lambda procedure will have it be the frame the procedure was **defined** in, while a mu procedure will have it be the frame the procedure was **called** in. Think: What is the difference in `env` and `self.env` when you use your `make_call_frame` function?"
                },
                {
                    "feedback": "This is unlocking the test, not passing it, mb! IDK what the output would be!!"
                },
                {
                    "feedback": "We are calling the **lambda** function `g`, and the lambda function was defined in the global frame, so the new child frame—which we will call f1—will be a child of the global frame. We **call** `f` in that child frame, so even though `f` was *defined* in the global frame, its new child frame will be a child of f1 because that’s where it was **called**. See if you can figure out what all the variables evaluate to based on that. Try drawing the environment diagram (modified to work with mu functions) if you can’t figure it out."
                }
            ]
        }
    ]
}